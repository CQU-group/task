
"""
名称：example
功能：使用泰勒公式近似sinx
作者：bigaym
时间：2022年3月12日14:07:49
"""


def taylor_sin(x:float, order:int):
    """
    使用泰勒公式近似sinx
    :param x: x
    :param order:阶数，越高越准但越慢
    :return: 结果
    """
    e = x
    s = x
    for i in range(2, order):
        e = -1*e*x*x/((2*i-1)*(2*i-2))
        s += e
    return s


if __name__ == '__main__':
    import time
    import math

    startTime = time.time()
    x = 3.14
    print(taylor_sin(x, 200))
    testTime = time.time()

    print(math.sin(x))
    mathTime = time.time()
    print(testTime-startTime, mathTime-testTime)
# -*- coding: utf-8 -*-
"""
@function： GUI，张诚明进行了最主要设计，敖钰民进行了微调
@author1: 张诚明
@author2: 敖钰民
@last_time： 2022年3月26晚
"""
# Form implementation generated from reading ui file 'GUI.UI'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_HelloWorld(object):
    def __init__(self):
        self.fnc = "sin"
        self.md = "角度制"

    def setupUi(self, HelloWorld):
        HelloWorld.setObjectName("HelloWorld")
        HelloWorld.resize(709, 327)
        self.centralwidget = QtWidgets.QWidget(HelloWorld)
        self.centralwidget.setObjectName("centralwidget")
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(150, 20, 511, 101))
        self.label.setObjectName("label")
        self.cal_Button = QtWidgets.QPushButton(self.centralwidget)
        self.cal_Button.setGeometry(QtCore.QRect(300, 220, 61, 28))
        self.cal_Button.setObjectName("cal_Button")
        self.input = QtWidgets.QLineEdit(self.centralwidget)
        self.input.setGeometry(QtCore.QRect(130, 210, 131, 41))
        self.input.setPlaceholderText("输入要计算的值")
        self.input.setObjectName("input")
        self.mode_select = QtWidgets.QComboBox(self.centralwidget)
        self.mode_select.setGeometry(QtCore.QRect(130, 170, 91, 22))
        self.mode_select.setObjectName("mode_select")
        self.mode_select.activated[str].connect(self.mode)  # 模式选择的回调函数
        self.mode_select.addItem("")
        self.mode_select.addItem("")
        self.output = QtWidgets.QLineEdit(self.centralwidget)
        self.output.setGeometry(QtCore.QRect(410, 210, 131, 41))
        self.output.setText("")
        self.output.setPlaceholderText("输出结果")
        self.output.setObjectName("output")
        self.func_select = QtWidgets.QComboBox(self.centralwidget)
        self.func_select.setGeometry(QtCore.QRect(130, 130, 91, 22))
        self.func_select.setObjectName("func_select")
        self.func_select.activated[str].connect(self.func)  # 函数选择的回调函数
        self.func_select.addItem("")
        self.func_select.addItem("")
        self.func_select.addItem("")
        self.func_select.addItem("")
        HelloWorld.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(HelloWorld)
        self.statusbar.setObjectName("statusbar")
        HelloWorld.setStatusBar(self.statusbar)
        self.actionSave = QtWidgets.QAction(HelloWorld)
        self.actionSave.setObjectName("actionSave")
        self.actionExit = QtWidgets.QAction(HelloWorld)
        self.actionExit.setObjectName("actionExit")
        self.actionType_Here = QtWidgets.QAction(HelloWorld)
        self.actionType_Here.setObjectName("actionType_Here")
        self.actionAdd_Separator = QtWidgets.QAction(HelloWorld)
        self.actionAdd_Separator.setObjectName("actionAdd_Separator")
        self.actionHello1 = QtWidgets.QAction(HelloWorld)
        self.actionHello1.setObjectName("actionHello1")
        self.actionHello2 = QtWidgets.QAction(HelloWorld)
        self.actionHello2.setObjectName("actionHello2")

        # 其他参数
        self.fnc = "sin"

        self.retranslateUi(HelloWorld)
        QtCore.QMetaObject.connectSlotsByName(HelloWorld)

    def retranslateUi(self, HelloWorld):
        _translate = QtCore.QCoreApplication.translate
        HelloWorld.setWindowTitle(_translate("HelloWorld", "三角函数计算器"))
        self.label.setToolTip(_translate("HelloWorld", "<html><head/><body><p><span style=\" font-size:48pt; font-weight:600;\">汇率转换器</span></p></body></html>"))
        self.label.setText(_translate("HelloWorld", "<html><head/><body><p><span style=\" font-size:28pt; font-weight:600;\">三角函数计算器</span></p></body></html>"))
        self.cal_Button.setText(_translate("HelloWorld", "计算"))
        self.mode_select.setItemText(0, _translate("HelloWorld", "角度制"))
        self.mode_select.setItemText(1, _translate("HelloWorld", "弧度制"))
        self.func_select.setItemText(0, _translate("HelloWorld", "sin"))
        self.func_select.setItemText(1, _translate("HelloWorld", "cos"))
        self.func_select.setItemText(2, _translate("HelloWorld", "arcsin"))
        self.func_select.setItemText(3, _translate("HelloWorld", "arctan"))
        self.actionSave.setText(_translate("HelloWorld", "Save"))
        self.actionExit.setText(_translate("HelloWorld", "Exit"))
        self.actionType_Here.setText(_translate("HelloWorld", "Type Here"))
        self.actionAdd_Separator.setText(_translate("HelloWorld", "Add Separator"))
        self.actionHello1.setText(_translate("HelloWorld", "Hello1"))
        self.actionHello2.setText(_translate("HelloWorld", "Hello2"))

    # 函数选择的回调函数
    def func(self):
        self.fnc = self.func_select.currentText()

    # 模式选择的回调函数
    def mode(self):
        self.md = self.mode_select.currentText()
# -*- coding: utf-8 -*-
"""
@function： 判断str类型数据是否可以转为float
@author: 敖钰民
@last_time： 2022年3月27日19:42:11
"""


def isFloat(input: str):
    """
    检测输入是否为float
    :param input:字符串
    :return:True 是； False 否
    """
    try:
        float(input)
    except:
        return False
    else:
        return True
# -*- coding: utf-8 -*-
"""
@function： 使用GUI模块和处理模块构造主函数以实现计算
@author: 敖钰民
@time： 2022年3月27日19:42:11
"""
import sys
from PyQt5.QtWidgets import QApplication, QMainWindow
from functools import partial
import GUI
from input import *
import process


# 处理GUI的事件的函数
def calculator(ui):
    """
    当用户按下计算时，在这里处理
    :param ui:pyqt5创建的ui类的对象
    :return:
            0：正常退出
            -1：不能转为float
            -2：模式设置错误
            -3：函数设置错误
            -4：输入范围不对
    """
    # 输入框内容
    input0 = ui.input.text()
    # 选择的函数（sin,cos等）
    fnc = ui.fnc
    # 选择的模式（角度/弧度）
    md = ui.md
    # 精确位数
    order = 8

    # 判断是否为float
    if not isFloat(input0):
        ui.output.setText("类型错误，请重输")
        return -1
    # 判断是否超出处理范围
    else:
        input0 = float(input0)
        if abs(input0) > 999999999:
            ui.output.setText("输入值过大")
            return -4
        # 判断弧度制还是角度制
        if md == "角度制":
            input0 = (input0*3.141592653589793)/180
        elif (md != "角度制") and (md != "弧度制"):
            ui.output.setText("模式设置错误")
            print("GUI错误：模式库里面没有{}模式".format(md))
            return -2
        # 根据选择的函数类型进行计算
        if fnc == "sin":
            result = process.taylor_sin(input0, order)
        elif fnc == "cos":
            result = process.taylor_cos(input0, order)
        elif fnc == "arcsin":
            # 检查是否超出arcsin定义域
            if (input0 > 1) or (input0 > 1):
                ui.output.setText("输入绝对值不应大于1")
                return -4
            result = process.taylor_arcsin(input0, order)
        elif fnc == "arctan":
            result = process.taylor_arctan(input0, order)
        else:
            ui.output.setText("函数设置错误")
            print("GUI错误：函数库里面没有{}函数".format(fnc))
            return -3
    # 输出结果精度设定
    result = round(result, order)
    print("calculate: func:{}, mode:{}, value:{}, result:{}".format(fnc, md, input0, result))
    # 输出框显示
    ui.output.setText(str(result))
    return 0


# 主函数
if __name__ == '__main__':
    # 创建程序
    app = QApplication(sys.argv)
    # 定义主窗口
    MainWindow = QMainWindow()
    # 定义UI
    ui = GUI.Ui_HelloWorld()
    # 设置UI
    ui.setupUi(MainWindow)
    # 显示窗口
    MainWindow.show()

    # 开始进入到数据处理
    ui.cal_Button.clicked.connect(partial(calculator, ui))   #如果按钮被点击，则调用convert函数

    sys.exit(app.exec_())
# -*- coding: utf-8 -*-
"""
@function： 判断str类型数据是否可以转为float
@author: 敖钰民
@last_time： 2022年3月27日19:42:11
"""
# PI的值
PI = 3.141592653589793

def pow(x: int, n:int):
    """
    返回x的n次方
    :param x: 求n次方的数
    :param n:n次方
    :return:
    """
    if n==1:
        return x
    m = 1
    for i in range(n-1):
        m = m*x
    return m


def taylor_sin(x: float, order: int):
    """
    使用泰勒公式近似 sin x
    :param x: x
    :param order:精度
    :return: 结果
    """
    # 调整到[-PI, PI]
    ratio = int(x/PI)
    if (ratio % 2) != 0:
        if ratio < 0:
            ratio = ratio - 1
        elif ratio > 0:
            ratio = ratio + 1
    x = x - ratio*PI


    e = x   # 迭代项
    s = x   # 初始项
    for i in range(2, 999999999):
        e = -1*e*x*x/((2*i-1)*(2*i-2))
        if abs(e) < 1/(pow(10, order+2)):
            return s
        s += e
    return s


def taylor_cos(x: float, order: int):
    """
    使用泰勒公式近似 cosx
    :param x: x
    :param order:精度
    :return: 结果
    """
    # 调整到[-PI, PI]
    ratio = int(x / PI)
    if (ratio % 2) != 0:
        if ratio < 0:
            ratio = ratio - 1
        elif ratio > 0:
            ratio = ratio + 1
    x = x - ratio * PI

    e = 1
    s = 1
    for i in range(1, 999999999):
        e = -1*e*x*x/((2*i-1)*(2*i))
        if abs(e) < 1/(pow(10, order+2)):
            return s
        s += e
    return s


def taylor_arcsin(x: float, order: int):
    """
    计算arcsin
    :param x:[-1, 1]
    :param order: 精确位数
    :return: 结果
    """
    if x == 1:
        return PI/2
    elif x == -1:
        return -PI/2
    if -1 < x < 1:
        e = x
        s = x
        i = 1
        n = 1
        cft = 1
        while True:
            e = e * x * x
            cft = cft * (2 * i - 1) / (2 * i)
            e1 = cft / (2 * n + 1)
            e1 = e * e1
            s = e1 + s
            i = i + 1
            n = n + 1

            if abs(e1) <= 1/(pow(10, order+2)):
                return s


def atan(x: float, order: int):
    """
    返回-1~1之间的arctan的值
    :param x: [-1,1]
    :param order: 精度
    :return:
    """
    e = x
    s = x
    for i in range(2, 999999999):
        e = -1 * e * x * x * (2 * i - 3) / (2 * i - 1)
        if abs(e) < 1 / (pow(10, order+1)):
            return s
        s += e
    return s

def taylor_arctan(x: float, order: int):
    """
    使用泰勒公式近似 arctan x
    :param x: x
    :param order:阶数，越高越准但越慢
    :return: 结果,输入错误是返回None
    注意：arctan(x) + arctan(1/x) = pi/2
    """
    if (x >= -1) and (x <= 1):
        return atan(x, order)
    elif x > 1:
        return PI/2 - atan(1/x, order)
    elif x < -1:
        return -(PI/2 - atan(-1/x, order))
    else:
        return None


if __name__ == '__main__':
    import math
    x = 0.6
    print(taylor_arcsin(x, 8))
    print(math.asin(x))
    import numpy as np
